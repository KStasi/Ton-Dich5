(cell, int, int) udict_get_min_ref(cell dict, int key_len) asm "DICTUMINREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, int, int) udict_get_max_ref(cell dict, int key_len) asm "DICTUMAXREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (int, cell, int)) ~udict::delete_get_min_ref(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";

(cell, cell, cell, cell, int, int) load_data() impure {
    ;; dict players, dict matches, dict prices, dict ban_requests, int seqno, int pubkey
    var ds = get_data().begin_parse();
    return (ds~load_dict(),
        ds~load_dict(), 
        ds~load_dict(), 
        ds~load_dict(), 
        ds~load_uint(32), 
        ds.preload_uint(256));
}

() store_data(cell players, cell matches, cell prices, cell ban_requests, int seqno, int public_key) impure {
    set_data(begin_cell()
        .store_dict(players)
        .store_dict(matches) 
        .store_dict(prices)
        .store_dict(ban_requests)
        .store_uint(seqno, 32)
        .store_uint(public_key, 256)
        .end_cell());
}

cell create_user(slice owner_address, cell users, int paid_until, int in_game, int bans_counter, cell units) impure {
    cell user = begin_cell()
        .store_uint(paid_until, 32)
        .store_uint(in_game, 1)
        .store_uint(bans_counter, 32)
        .store_dict(units)
        .end_cell();
    users~idict_set_ref(256, slice_hash(owner_address), user);
    return users;
}

(int, int, int, cell) get_user(slice owner_address, cell players) method_id {
    ;; int paid_until, int in_game, int bans_counter, cell units
    cell user = idict_get_ref(players, 256, slice_hash(owner_address));
    if (user.null?()) {
        return (0, 0, 0, user);
    }
    slice s_user = user.begin_parse();
    return (s_user~load_uint(32), s_user~load_uint(1), s_user~load_uint(32), s_user.preload_dict());

}

() update_prices(cell new_prices) impure {
    (cell players, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
    store_data(players, matches, new_prices, ban_requests, stored_seqno + 1, public_key);
}

int get_price(cell prices, int unit_id, int unit_level) method_id {
    cell unit = udict_get_ref(prices, 16, unit_id);
    if (unit.null?()) {
        return -1;
    }
    (slice s_price, int f) = unit.udict_get?(8, unit_level);
    ifnot (f) {
        return -1;
    }
    return s_price.preload_uint(32);
}

cell update_units_counter(cell units, int unit_id, int unit_level, int units_counter, int shouldAdd) impure {
    cell units_by_level = udict_get_ref(units, 8, unit_level);
    (slice s_counter, int f) = units_by_level.udict_get?(16, unit_id);
    int counter = 0;
    if (f) {
        counter = s_counter.preload_uint(16);
    }
    if (shouldAdd) {
        counter += units_counter;
        throw_if(52, counter > 255); ;; too many units of one type
    } else {
        counter -= units_counter;
        throw_if(53, counter < 0); ;; underflow units of one type
    }
    units_by_level~udict_set(16, unit_id, begin_cell().store_uint(counter, 16).end_cell().begin_parse());
    units~udict_set_ref(8, unit_level, unit);
    return units;
}

() buy_unit(slice owner_address, int unit_id, int unit_level, int units_counter, int msg_value) impure {
    (cell players, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
    int price = get_price(prices, unit_id, unit_level);
    throw_if(50, price == -1); ;; unit can't be sold
    throw_if(51, price * units_counter > msg_value); ;; unsufficient funds
    (int paid_until, int in_game, int bans_counter, cell units) = get_user(owner_address, players);
    units = update_units_counter(units, unit_id, unit_level, units_counter, true);
    players = create_user(owner_address, players, paid_until, in_game, bans_counter, units);
    return store_data(players, matches, prices, ban_requests, stored_seqno, public_key);
}

(cell, int) push_queue(cell matches, slice owner_address, int valid_until, cell unit_pool) impure {
    cell queue = udict_get_ref(matches, 2, 0);
    (cell last_player, int idx, int f) = udict_get_max_ref(queue, 4);
    if(f) {
        idx += 1;
    }
    cell player = begin_cell()
        .store_uint(valid_until, 32)
        .store_int(slice_hash(owner_address), 256)
        .store_dict(unit_pool)
        .end_cell();
    queue~udict_set_ref(4, idx, player);
    matches~udict_set_ref(2, 0, queue);
    return (matches, idx);
}

cell start_game(cell matches) impure {
    cell queue = udict_get_ref(matches, 2, 0);
    cell games = udict_get_ref(matches, 2, 1);
    cell unit_pool_by_level = new_dict(); 
    int i = 0;
    do {
        (int idx, cell player, int f) = queue~udict::delete_get_min_ref(4);
        ;; set units by level 
        ;; create players
        ;; 
    } until(~f)
    (cell last_game, int idx, int f) = udict_get_max_ref(games, 8);
    if(f) {
        idx += 1;
    }
    cell game = begin_cell()
        .store_dict(unit_pool_by_level)
        .store_dict(players)
        .store_dict(new_dict())
        .store_dict(new_dict())
        .end_cell();
    games~udict_set_ref(8, idx, game);
    matches~udict_set_ref(2, 0, queue);
    matches~udict_set_ref(2, 1, games);
    return matches;
}

() line_up_to_match(slice owner_address, int valid_until, cell unit_pool, int msg_value) impure {
    ;; unit pool is [(counter) (type)](8)
    ;; check user status
    ;; check game fee and valid unit
    ;; for each level 
    ;;     check if sum(counter) == 8
    ;;     decrement units
    ;; push queue
    ;; if queue.length == 8
    ;;      start game
    ;; block user
}



() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (msg_seqno, valid_until) = (cs~load_uint(32), cs~load_uint(32));
  throw_if(35, valid_until <= now());
  var ds = get_data().begin_parse();
  (cell players, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
  ds.end_parse();
  throw_unless(33, msg_seqno == stored_seqno);
  throw_unless(34, check_signature(slice_hash(in_msg), signature, public_key));
  accept_message();
  cs~touch();
  while (cs.slice_refs()) {
    var mode = cs~load_uint(8);
    send_raw_message(cs~load_ref(), mode);
  }
  cs.end_parse();
  store_data(players, matches, prices, ban_requests, stored_seqno + 1, public_key);
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}