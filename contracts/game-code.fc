(cell, int, int) udict_get_min_ref(cell dict, int key_len) asm "DICTUMINREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, int, int) udict_get_max_ref(cell dict, int key_len) asm "DICTUMAXREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (int, cell, int)) ~udict::delete_get_min_ref(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, int, cell, int) udict_delete_get_min_ref(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(slice, int, int) udict_get_min?(cell dict, int key_len) asm "DICTUMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(slice, int, int) udict_get_max?(cell dict, int key_len) asm "DICTUMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";

forall X -> tuple tuple_push(tuple list, X x) asm "TPUSH";
forall X -> (tuple, X) tuple_pop(tuple list) asm "TPOP";
forall X -> tuple tuple_set_index(tuple list, X x, int k) asm "SETINDEXVAR";
forall X -> X tuple_get_index(tuple list, int k) asm "INDEXVAR";
forall X -> tuple single(X x) asm "SINGLE";


(cell, cell, cell, cell, int, int) load_data() method_id {
    ;; dict users, dict matches, dict prices, dict ban_requests, int seqno, int pubkey
    var ds = get_data().begin_parse();
    return (ds~load_dict(),
        ds~load_dict(), 
        ds~load_dict(), 
        ds~load_dict(), 
        ds~load_uint(32), 
        ds.preload_uint(256));
}

() store_data(cell users, cell matches, cell prices, cell ban_requests, int seqno, int public_key) impure {
    set_data(begin_cell()
        .store_dict(users)
        .store_dict(matches) 
        .store_dict(prices)
        .store_dict(ban_requests)
        .store_uint(seqno, 32)
        .store_uint(public_key, 256)
        .end_cell());
}

cell create_user(int owner_hash, cell users, int paid_until, int game_idx, int bans_counter, cell units) impure {
    slice user = begin_cell()
        .store_uint(paid_until, 32)
        .store_uint(game_idx, 8)
        .store_uint(bans_counter, 32)
        .store_dict(units)
        .end_cell()
        .begin_parse();
    users~udict_set(256, owner_hash, user);
    return users;
}

(int, int, int, cell) get_user(int owner_hash, cell users) method_id {
    ;; int paid_until, int in_game, int bans_counter, cell units
    (slice s_user, int f) = users.udict_get?(256, owner_hash);
    ifnot (f) {
        return (0, 0, 0, new_dict());
    }
    return (s_user~load_uint(32), s_user~load_uint(8), s_user~load_uint(32), s_user.preload_dict());

}

() update_prices(cell new_prices) impure {
    (cell users, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
    store_data(users, matches, new_prices, ban_requests, stored_seqno + 1, public_key);
}

int get_price(cell prices, int unit_id, int unit_level) method_id {
    ;;cell unit = udict_get_ref(prices, 16, unit_id);
    (slice s_unit, int f) = prices.udict_get?(16, unit_id);
    ifnot (f) {
        return -1;
    }
    cell unit = s_unit~load_ref();
    if (unit.null?()) {
        return 0; 
    }

    (slice s_price, int f) = unit.udict_get?(8, unit_level);
    ifnot (f) {
        return -1;
    }
    return s_price.preload_uint(32);
}
int get_unit(cell units, int unit_id, int unit_level) method_id {
    cell units_by_level = udict_get_ref(units, 8, unit_level);
    (slice s_counter, int f) = units_by_level.udict_get?(16, unit_id);
    int counter = 0;
    if (f) {
        counter = s_counter.preload_uint(16);
    }
    return counter;
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cell update_units_counter(cell units, int unit_id, int unit_level, int units_counter, int shouldAdd) impure {
    cell units_by_level = udict_get_ref(units, 8, unit_level);
    (slice s_counter, int f) = units_by_level.udict_get?(16, unit_id);
    int counter = 0;
    if (f) {
        counter = s_counter.preload_uint(16);
    }
    if (shouldAdd) {
        counter += units_counter;
        throw_if(52, counter > 255); ;; too many units of one type
    } else {
        counter -= units_counter;
        throw_if(53, counter < 0); ;; underflow units of one type
    }
    units_by_level~udict_set(16, unit_id, begin_cell().store_uint(counter, 16).end_cell().begin_parse());
    units~udict_set_ref(8, unit_level, units_by_level);
    return units;
}

cell update_units_list(cell units, int unit_id, int unit_level, int counter) impure {
    cell units_by_level = udict_get_ref(units, 8, unit_level);
    var(unit_type, idx, f) = udict_get_max?(units_by_level, 16);
    ifnot (f) {
        idx = 0;
    }
    while (counter) {
        idx += 1;
        units_by_level~udict_set(16, idx, begin_cell().store_uint(unit_id, 16).end_cell().begin_parse());
        counter -= 1;
    }
    throw_if(99, units_by_level.null?());
    units~udict_set_ref(8, unit_level, units_by_level);
    return units;
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
() buy_unit(slice owner_address, int unit_id, int unit_level, int units_counter, int msg_value) impure {
    (cell users, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
    int price = get_price(prices, unit_id, unit_level);
    throw_if(50, price == -1); ;; unit can't be sold
    throw_if(51, price * units_counter > msg_value); ;; unsufficient funds
    (int paid_until, int in_game, int bans_counter, cell units) = get_user(slice_hash(owner_address), users);
    units = update_units_counter(units, unit_id, unit_level, units_counter, true);
    users = create_user(slice_hash(owner_address), users, now() + 100000, in_game, bans_counter, units);
    return store_data(users, matches, prices, ban_requests, stored_seqno, public_key);
}

(cell, int) push_queue(cell matches, slice owner_address, int valid_until, cell unit_pool) impure {
    cell queue = udict_get_ref(matches, 2, 0);
    var (last_player, idx, f) = udict_get_max_ref(queue, 4);
    if (f) {
        idx += 1;
    } else {
        idx = 0;
    }
    cell player = begin_cell()
        .store_uint(valid_until, 32)
        .store_uint(slice_hash(owner_address), 256)
        .store_dict(unit_pool)
        .end_cell();
    queue~udict_set_ref(4, idx, player);
    matches~udict_set_ref(2, 0, queue);
    return (matches, idx);
}

(int, int, cell) get_candidate(cell player) method_id {
    slice s_player = player.begin_parse();
    return (s_player~load_uint(32), s_player~load_uint(256), s_player.preload_dict());
}

cell store_player(cell players, int idx, int player_hash, cell unit_pool, int gold, int level, int exp, int hp) impure {
    cell player = begin_cell()
        .store_uint(player_hash, 256)
        .store_uint(gold, 8)
        .store_uint(level, 8)
        .store_uint(exp, 8)
        .store_uint(hp, 8)
        .store_dict(unit_pool)
        .end_cell();
    players~udict_set_ref(8, idx, player);
    return players;
}

(int, int, int, int, int, cell) get_player(cell players, int idx) impure {
    cell player = players.udict_get_ref(8, idx);
    if (player.null?()) {
        return (0, 0, 0, 0, 0, player);
    }
    slice player_slice = player.begin_parse();
    return (
        player_slice~load_uint(256),
        player_slice~load_uint(8),
        player_slice~load_uint(8),
        player_slice~load_uint(8),
        player_slice~load_uint(8),
        player_slice~load_dict());
}

(int, int, int, int) get_player_state(cell players, int idx) impure {
    var (player, f) = players.udict_get?(8, idx);
    ifnot (f) {
        return (0, 0, 0, 0);
    }
    return (
        player~load_uint(8),
        player~load_uint(8),
        player~load_uint(8),
        player~load_uint(8));
}

cell create_game(cell games, int idx, int valid_unitl, int should_start_round, cell unit_pool_by_level, cell players, cell current_round, cell last_round_results, int timeout) impure {
    cell game = begin_cell()
        .store_uint(valid_unitl, 32)
        .store_int(should_start_round, 1)
        .store_uint(timeout, 32)
        .store_dict(unit_pool_by_level)
        .store_dict(players)
        .store_dict(current_round)
        .store_dict(last_round_results)
        .end_cell();
    games~udict_set_ref(8, idx, game);
    return games;
}

(int, int, int, cell, cell, cell,cell) get_game(cell games, int idx) impure {
    ;; int should_start_round, int timeout, cell unit_pool_by_level, cell players, cell current_round, cell last_round_results
    cell game = udict_get_ref(games, 8, idx);
    if (game.null?()) {
        return (0, 0, 0, game, game, game, game);
    }
    slice s_game = game.begin_parse();
    return (
        s_game~load_uint(32),
        s_game~load_int(1),
        s_game~load_uint(32),
        s_game~load_dict(),
        s_game~load_dict(),
        s_game~load_dict(),
        s_game~load_dict()
    );
}

tuple cell_to_tuple(cell list_cell, int key_len ) impure {
    slice list_slice = list_cell.begin_parse();
    var list = nil;
    int tuple_len = 0;
    while(list_slice.slice_bits()) {
        int el = list_slice~load_uint(key_len);
        ifnot (tuple_len) {
            list = single(el);
        } else {
            list = tuple_push(list, el);
        }
        tuple_len += 1;
    }
    return list;
}

cell get_store(cell current_round) impure {
    cell levels_distribution = udict_get_ref(current_round, 4, 0);
    return levels_distribution;
}

tuple get_level_store(cell levels_distribution, int level) impure {
    var units_distribution = udict_get_ref(levels_distribution, 4, level);
    if (units_distribution.null?()) {
        return nil;
    }
    return cell_to_tuple(units_distribution, 4);
}

cell create_position(cell positions, cell locations, int idx) impure {
    positions~udict_set_ref(8, idx, locations);
    return positions;
}

cell update_players_counter(cell players, int players_counter, int key_len, int idx, int shouldAdd) impure {
    cell players_counter_cell = udict_get_ref(players, key_len, idx);
    int counter = 0;
    ifnot (players_counter_cell.null?()) {
        slice s_counter = players_counter_cell.begin_parse();
        counter = s_counter.preload_uint(16);
    }
    if (shouldAdd) {
        counter += players_counter;
    } else {
        counter -= players_counter;
    }
    players~udict_set_ref(key_len, idx, begin_cell().store_uint(counter, 16).end_cell());
    return players;
}

int get_players_count(cell players) impure {
    cell players_counter_cell = udict_get_ref(players, 8, 0);
    ifnot (players_counter_cell.null?()) {
        slice s_counter = players_counter_cell.begin_parse();
        return s_counter.preload_uint(16);
    }
    return 0;
}
;; TODO: restrict changes
;; TODO: optimize store
() arrange_units(slice owner_address, int player_idx, int idx, cell locations) impure {
    (cell users, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, idx);
    throw_if(59, timeout < now());
    throw_if(62, locations.null?());
    cell positions = udict_get_ref(current_round, 4, 1);
    var store = get_store(current_round);
    var (player_hash, gold, user_level, exp, hp, unit_pool) = get_player(players, player_idx);
    throw_unless(63, player_hash == slice_hash(owner_address));
    var (level_info, level, f1) = udict_get_min?(locations, 4);
    while (f1) {
        cell level_distribution = level_info.preload_dict();
        var level_store = get_level_store(store, level);
        var (coordinats, unit_idx, f2) = udict_get_min?(level_distribution, 16);
        while (f2) {
            ;; var (x, y) = (coordinats~load_int(16), coordinats~load_int(16));
            int buyer_idx = tuple_get_index(level_store, unit_idx);
            throw_unless(60, buyer_idx == player_idx); ;; purchase not allowed
            gold -= 1;
            throw_if(61, gold < 0); ;; not enoght money
            (unit_idx, coordinats, f2) = udict_get_next?(level_distribution, 16, unit_idx);
        }
        
        (level, level_info, f1) = udict_get_next?(locations, 4, level);
    }
    positions = create_position(positions, locations, player_idx);
    current_round~udict_set_ref(4, 1, positions);
    current_round = update_players_counter(current_round, 1, 4, 2, true);
    int players_in_game = udict_get_ref(current_round, 4, 2).begin_parse().preload_uint(16);
    players = store_player(players, player_idx, player_hash, unit_pool, gold, user_level, exp, hp);
    games = create_game(games, idx, valid_unitl, players_in_game < get_players_count(players), unit_pool_by_level, players, current_round, last_round_results, timeout);
    matches~udict_set_ref(2, 1, games);
    return store_data(users, matches, prices, ban_requests, stored_seqno, public_key);
}


tuple exchange(tuple list, idx_a, int idx_b) impure {
    int tmp_value = tuple_get_index(list, idx_a);
    list = tuple_set_index(list, tuple_get_index(list, idx_b), idx_a);
    return tuple_set_index(list, tmp_value, idx_b);
}

tuple distribute_units_per_level(int units_per_level_count, int players_count) impure {
    int units_per_player_count = units_per_level_count / players_count;
    var units_distribution_per_level = nil;
    int tuple_len = 0;
    int player_idx = 0; 
    while ((player_idx < players_count) & (tuple_len < units_per_level_count)) {
        ifnot (tuple_len) {
            units_distribution_per_level = single(player_idx + 1);
        } else {
            units_distribution_per_level = tuple_push(units_distribution_per_level, player_idx + 1);
        }
        player_idx += 1;
        if (player_idx == players_count) {
            player_idx = 0;
        }
        tuple_len += 1;
    }
    ;; shuffle
    while (tuple_len) {
        int r = rand(tuple_len);
        tuple_len -= 1;
        units_distribution_per_level = exchange(units_distribution_per_level, r, tuple_len);
    }
    return units_distribution_per_level;
}

cell tuple_to_cell(tuple list, int key_len, int list_len) impure {
    builder list_cell = begin_cell();
    int el = 0;
    while(list_len) {
        (list, el) = tuple_pop(list);
        list_cell~store_uint(el, key_len);
        list_len -= 1;
    }
    return list_cell.end_cell();
}

cell store_distribution_per_level(cell current_round, tuple units_distribution_per_level, int units_per_level_count, int level) impure {
    cell units_distribution = tuple_to_cell(units_distribution_per_level, 4, units_per_level_count);
    cell level_distribution = udict_get_ref(current_round, 4, 0);
    level_distribution~udict_set_ref(4, level, units_distribution);
    current_round~udict_set_ref(4, 0, level_distribution);
    return current_round;
}

cell start_round(cell games, int idx) impure {
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, idx);
    last_round_results = current_round;
    current_round = new_dict();
    int players_count = get_players_count(players);
    cell units_counter_by_level = udict_get_ref(unit_pool_by_level, 8, 0);
    var (units, level, f) = udict_get_min?(units_counter_by_level, 16);
    while (f) {
        int units_per_level_count = units.preload_uint(16);
        var units_distribution_per_level = distribute_units_per_level(units_per_level_count, players_count);
        current_round = store_distribution_per_level(current_round, units_distribution_per_level, units_per_level_count, level);
        (level, units, f) = udict_get_next?(units_counter_by_level, 16, level);
        dump_stack();
    }
    games = create_game(games, idx, valid_unitl, should_start_round, unit_pool_by_level, players, current_round, last_round_results, timeout);
    return games;
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cell start_game(cell matches) impure {
    var (matches, idx, queue, f) = udict_delete_get_min_ref(matches, 2);
    cell games = udict_get_ref(matches, 2, 1);
    cell unit_pool_by_level = new_dict(); 
    int i = 0;
    cell players = new_dict();
    var (queue, idx, player, f) = udict_delete_get_min_ref(queue, 4);
    while (f) {
        var (valid_until, player_hash, unit_pool) = get_candidate(player);
        var (unit_pool, level, level_units, f1) = udict_delete_get_min(unit_pool, 4);
        while (f1) {
            while (level_units.slice_bits()) {
                (int counter, int unit_id) = (level_units~load_uint(8), level_units~load_uint(16));
                unit_pool_by_level = update_units_list(unit_pool_by_level, unit_id, level, counter);
            }
            (unit_pool, level, level_units, f1) = udict_delete_get_min(unit_pool, 4);
        }
        unit_pool_by_level = update_units_counter(unit_pool_by_level, idx + 1, 0, 64, true); ;; update units counter per level
        players = store_player(players, idx + 1, player_hash, new_dict(), 1, 1, 0, 100);
        (queue, idx, player, f) = udict_delete_get_min_ref(queue, 4);
    }
    var (last_game, idx, f) = udict_get_max_ref(games, 8);
    if(f) {
        idx += 1;
    } else {
        idx = 1;
    }
    players = update_players_counter(players, 8, 8, 0, true);
    games = create_game(games, idx, now() + 40000, true, unit_pool_by_level, players, new_dict(), new_dict(), now() + 7200);
    games = start_round(games, idx);
    ;; dump_stack();
    matches~udict_set_ref(2, 1, games);
    return matches;
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
int get_next_game_idx(cell matches) method_id {
    cell games = udict_get_ref(matches, 2, 1);
    var (last_game, idx, f) = udict_get_max_ref(games, 8);
    if(f) {
        return idx + 1;
    } else {
        return 1;
    }
}
cell store_result(cell current_round, slice new_dict, int idx, int player_idx) impure {
    cell dict = udict_get_ref(current_round, 4, idx);
    dict~udict_set(4, player_idx, new_dict);
    current_round~udict_set_ref(4, idx, dict);
    return current_round;
}

cell update_board(cell boards, int new_result, int new_units_count, int new_stars, int key_len, int idx, int shouldAdd) impure {
    ;;; ?????????????
    var (board_info, f) = udict_get?(boards, key_len, idx);
    int result = 0;
    int units_count = 0;
    int stars = 0;
    if (f) {
        (result, units_count, stars) = (board_info~load_uint(8), board_info~load_uint(32), board_info~load_uint(32));
    }
    if (shouldAdd) {
        result += new_result;
        units_count += new_units_count;
        stars += new_stars;
    } else {
        result /= new_result;
        units_count /= new_units_count;
        stars /= new_stars;
    }
    ;;; ?????????????
    boards~udict_set(key_len, idx, begin_cell().store_uint(result, 8).store_uint(units_count, 32).store_uint(stars, 32).end_cell().begin_parse());
    return boards;
}

cell update_players_state_counter(cell new_players_state, int new_gold, int new_level, int new_exp, int new_hp, int key_len, int idx, int shouldAdd) impure {
    var (new_players_state_info, f) = udict_get?(new_players_state, key_len, idx);
    int gold = 0;
    int level = 0;
    int exp = 0;
    int hp = 0;
    if (f) {
        (gold, level, exp, hp) = (new_players_state_info~load_uint(16), new_players_state_info~load_uint(16), new_players_state_info~load_uint(16), new_players_state_info~load_uint(16));
    }
    if (shouldAdd) {
        gold += new_gold;
        level += new_level;
        exp += new_exp;
        hp += new_hp;
    } else {
        gold /= new_gold;
        level /= new_level;
        exp /= new_exp;
        hp /= new_hp;
    }
    new_players_state~udict_set(key_len, idx, begin_cell().store_uint(gold, 16).store_uint(level, 16).store_uint(exp, 16).store_uint(hp, 16).end_cell().begin_parse());
    return new_players_state;
}

(cell, cell) end_game(cell players, cell unit_pool_by_level, cell users, int player_idx, cell positions) impure {
    int owner_hash = players.udict_get_ref(8, player_idx).begin_parse().preload_uint(256);

    var (paid_until, in_game, bans_counter, units) = get_user(owner_hash, users);
    cell players_locations = positions.udict_get_ref(8, player_idx);
    var (level_info, level, f1) = udict_get_min?(players_locations, 4);
    while (f1) {
        cell level_distribution = level_info.preload_dict();
        int level_counter = 0;
        var (coordinats, unit_idx_in_tuple, f2) = udict_get_min?(level_distribution, 16);
        cell units_by_level = udict_get_ref(unit_pool_by_level, 8, level);

        while (f2) {
            (slice s_unit_idx, int f) = units_by_level~udict_delete_get?(16, unit_idx_in_tuple);
            int unit_idx = s_unit_idx.preload_uint(16);
            units = update_units_counter(units, unit_idx, level, 1, true);
            level_counter += 1;
            (unit_idx_in_tuple, coordinats, f2) = udict_get_next?(level_distribution, 16, unit_idx_in_tuple);
        }
        unit_pool_by_level~udict_set_ref(8, level, units_by_level);
        unit_pool_by_level = update_units_counter(unit_pool_by_level, level, 0, level_counter, false);
        (level, level_info, f1) = udict_get_next?(players_locations, 4, level);
    }
    users = create_user(owner_hash, users, now() + 100000, false, bans_counter, units);
    return (unit_pool_by_level, users);
}

() end_round(int game_idx) impure {
    var (users, matches, prices, ban_requests, stored_seqno, public_key) = load_data();
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);

    cell board = new_dict();
    cell new_players_state = new_dict();
    int counter = 0;
    cell boards = udict_get_ref(current_round, 4, 3);
    cell new_players_states = udict_get_ref(current_round, 4, 4);

    ;; results are adjusted here
    var (boards_info_slice, author_idx, f1) = udict_get_min?(boards, 4);
    cell boards_info = boards_info_slice.preload_dict();
    var (new_players_states_info_slice, author_idx, f1) = udict_get_min?(new_players_states, 4);
    cell new_players_states_info = new_players_states_info_slice.preload_dict();
    while (f1) {
        counter += 1;
        var (board_info, board_idx, f2) = udict_get_min?(boards_info, 4);
        var (new_players_state_info, player_idx, f2) = udict_get_min?(new_players_states_info, 4);
        while (f2) {
            var (result, units_count, stars) = (board_info~load_uint(4), board_info~load_uint(16), board_info~load_uint(16));
            board = update_board(board, result, units_count, stars, 4, board_idx, true);
            var (gold, level, exp, hp) = (new_players_state_info~load_uint(8), new_players_state_info~load_uint(8), new_players_state_info~load_uint(8), new_players_state_info~load_uint(8));
            new_players_state = update_players_state_counter(new_players_state, gold, level, exp, hp, 4, player_idx, true);
            (board_idx, board_info, f2) = udict_get_next?(boards_info, 4, board_idx);
            (player_idx, new_players_state_info, f2) = udict_get_next?(new_players_states_info, 4, player_idx);
        }
        (author_idx, boards_info_slice, f1) = udict_get_next?(boards, 4, author_idx);
        (author_idx, new_players_states_info_slice, f1) = udict_get_next?(new_players_states, 4, author_idx);
        if (f1) {
            boards_info = boards_info_slice.preload_dict();
            new_players_states_info = new_players_states_info_slice.preload_dict();
        }
    }
    var (board_info, board_idx, f1) = udict_get_min?(board, 4);
    var (new_players_state_info, player_idx, f1) = udict_get_min?(new_players_state, 4);
    cell new_players = new_dict();
    cell positions = udict_get_ref(current_round, 4, 1);
    while (f1) {
        board = update_board(board, counter, counter, counter, 4, board_idx, false);
        var (player_hash, gold, user_level, exp, hp, unit_pool) = get_player(players, player_idx);
        var (gold, user_level, exp, hp) = (new_players_state_info~load_uint(16) / counter, new_players_state_info~load_uint(16) / counter, new_players_state_info~load_uint(16) / counter, new_players_state_info~load_uint(16) / counter);
        if (hp) {
            new_players = store_player(new_players, player_idx, player_hash, unit_pool, gold, user_level, exp, hp);
            new_players = update_players_counter(new_players, 1, 8, 0, true);
        } else {
            (unit_pool_by_level, users) = end_game(players, unit_pool_by_level, users, player_idx, positions);
        }
        (board_idx, board_info, f1) = udict_get_next?(board, 4, board_idx);
        (player_idx, new_players_state_info, f1) = udict_get_next?(new_players_state, 4, player_idx);
    }
    current_round~udict_set_ref(4, 3, board);
    games = create_game(games, game_idx, valid_unitl, true, unit_pool_by_level, new_players, current_round, last_round_results, timeout);
    matches~udict_set_ref(2, 1, games);
    return store_data(users, matches, prices, ban_requests, stored_seqno, public_key);

}

() send_round_results(slice owner_address, int player_idx, int game_idx, slice boards, slice new_players_state) impure {
    ;; cell board is udict(4); 0 => int4 result , int units_count , int stars count
    ;; cell new_players_state is udict(8); each is int gold, int level, int exp, int hp 
    var (users, matches, prices, ban_requests, stored_seqno, public_key) = load_data();
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    throw_if(64, should_start_round); ;; round should be started
    var (player_hash, gold, user_level, exp, hp, unit_pool) = get_player(players, player_idx);
    throw_unless(65, player_hash == slice_hash(owner_address));
    current_round = store_result(current_round, boards, 3, player_idx);
    current_round = store_result(current_round, new_players_state, 4, player_idx);
    int players_count = get_players_count(players);
    int players_in_game = udict_get_ref(current_round, 4, 2).begin_parse().preload_uint(16);
    if (players_in_game == players_count) {
        timeout = now() + 7200;
    }
    current_round = update_players_counter(current_round, 1, 4, 2, false);
    games = create_game(games, game_idx, valid_unitl, players_in_game == 1, unit_pool_by_level, players, current_round, last_round_results, timeout);
    matches~udict_set_ref(2, 1, games);
    store_data(users, matches, prices, ban_requests, stored_seqno, public_key);
    if (players_in_game == 1) {
        return end_round(game_idx);
    }
    return ();
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
() line_up_to_match(slice owner_address, int valid_until, cell unit_pool, int msg_value) impure {
    ;; unit pool is [(counter) (type)](8)
    throw_if(54, msg_value < 1000); ;; fee
    throw_if(55, valid_until < now() + 30); ;; interval limit
    throw_if(56, valid_until > now() + 7200); ;; interval limit
    var (users, matches, prices, ban_requests, stored_seqno, public_key) = load_data();
    var (paid_until, in_game, bans_counter, units) = get_user(slice_hash(owner_address), users);
    throw_if(57, in_game); ;; only one match is allowed simultaneously
    var (matches, queue_length) = push_queue(matches, owner_address, valid_until, unit_pool);
    var (unit_pool, level,  level_units, f) = udict_delete_get_min(unit_pool, 4);
    int level_counter = 0;
    while (f) {
        while (level_units.slice_bits()) {
            (int counter, int unit_id) = (level_units~load_uint(8), level_units~load_uint(16));
            level_counter += counter;
            units = update_units_counter(units, unit_id, level, counter, false);
        }

        throw_unless(58, level_counter == 8); ;; exactly 8 units per level are allowed
        (unit_pool, level, level_units, f) = udict_delete_get_min(unit_pool, 4);
        level_counter = 0;
    }
    ;; TODO: add level number check
    int game_idx = get_next_game_idx(matches);
    if (queue_length == 7) {
        matches = start_game(matches);
    }
    users = create_user(slice_hash(owner_address), users, paid_until, game_idx, bans_counter, units);
    return store_data(users, matches, prices, ban_requests, stored_seqno, public_key);
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

() recv_external(slice in_msg) impure {
    slice signature = in_msg~load_bits(512);
    slice cs = in_msg;
    (int msg_seqno, int valid_until) = (cs~load_uint(32), cs~load_uint(32));
    throw_if(35, valid_until <= now());
    (cell users, cell matches, cell prices, cell ban_requests, int stored_seqno, int public_key) = load_data();
    throw_unless(33, msg_seqno == stored_seqno);
    throw_unless(34, check_signature(slice_hash(in_msg), signature, public_key));
    accept_message();
    int op = cs~load_uint(32);
    if (op == 0) {
        while (cs.slice_refs()) {
            var mode = cs~load_uint(8);
            send_raw_message(cs~load_ref(), mode);
        }
        cs.end_parse();
        return store_data(users, matches, prices, ban_requests, stored_seqno + 1, public_key);
    }
    if (op == 0xaa1122) {
        cell new_prices = cs~load_dict();
        return update_prices(new_prices);
    }
    return ();
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  slice cs = in_msg_cell.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) {
    return ();
  }
  slice s_addr = cs~load_msg_addr();
  if (in_msg.slice_empty?()) {
    return ();
  }
  int op = in_msg~load_uint(32);
  if (op == 0) {
    return ();
  }
  int query_id = in_msg~load_uint(64);
  if (op == 0xaaeeee) {
    (int unit_id, int unit_level, int units_counter) = (in_msg~load_uint(16), in_msg~load_uint(8), in_msg~load_uint(16));
    return buy_unit(s_addr, unit_id, unit_level, units_counter, msg_value);
  }
  if (op == 0xbbeeee) {
    (int valid_until, cell unit_pool) = (in_msg~load_uint(32), in_msg~load_ref());
    return line_up_to_match(s_addr, valid_until, unit_pool, msg_value);
  }
  if (op == 0xcceeee) {
    (int player_idx, int game_idx, cell locations) = (in_msg~load_uint(8), in_msg~load_uint(8), in_msg~load_dict());
    return arrange_units(s_addr, player_idx, game_idx, locations);
  }
  if (op == 0xddeeee) {
    (int player_idx, int game_idx, cell boards, cell new_players_state) = (in_msg~load_uint(8), in_msg~load_uint(8), in_msg~load_dict(), in_msg~load_dict());
    return send_round_results(s_addr, player_idx, game_idx, begin_cell().store_dict(boards).end_cell().begin_parse(), begin_cell().store_dict(new_players_state).end_cell().begin_parse());
  }
  return ();
}

cell remove_expired(cell dict, int key_len) impure {
    var (value, key, f) = udict_get_min?(dict, key_len);
    while (f) {
        int valid_unitl = value.preload_uint(32);
        if (valid_unitl < now()) {
            (dict, f) = udict_delete?(dict, key_len, key);
        }
        (key, value, f) = udict_get_next?(dict, key_len, key);
    }
    return dict;
}

(cell, cell) remove_from_queue(cell queue, cell users) impure {
    var new_queue = new_dict();
    var (queue, idx, player, f) = udict_delete_get_min_ref(queue, 4);
    while (f) {
        var (valid_until, player_hash, unit_pool) = get_candidate(player);
        if (valid_until > now()) {
            new_queue~udict_set_ref(4, idx, player);
        } else {
            var (s_user, f) = users.udict_get?(256, player_hash);
            var (paid_until, in_game, bans_counter, units) = (0, 0, 0, new_dict());
            if (f) {
                (paid_until, in_game, bans_counter, units) = (s_user~load_uint(32), s_user~load_uint(8), s_user~load_uint(32), s_user.preload_dict());
            }
            slice user = begin_cell()
                .store_uint(paid_until, 32)
                .store_int(in_game, 1)
                .store_uint(bans_counter, 32)
                .store_dict(units)
                .end_cell()
                .begin_parse();
            users~udict_set(256, player_hash, user);
        }
        (queue, idx, player, f) = udict_delete_get_min_ref(queue, 4);
    }
    return (new_queue, users);
}

(cell, cell) remove_matches(cell matches, cell users) impure {
    var (matches, idx, queue, f1) = udict_delete_get_min_ref(matches, 2);
    var (matches, idx, games, f2) = udict_delete_get_min_ref(matches, 2);
    ifnot (f1) {
        (queue, users) = remove_from_queue(queue, users);
        ifnot (queue.null?()) {
            matches~udict_set_ref(2, 0, queue);
        }
    }
    ifnot (f2) {
        games = remove_expired(games, 4);
        ifnot (games.null?()) {
            matches~udict_set_ref(2, 1, games);
        }
    }
    return (matches, users);
}


() run_ticktock() impure {
    var (users, matches, prices, ban_requests, stored_seqno, public_key) = load_data();
    ifnot (ban_requests.null?()) {
        ban_requests = remove_expired(ban_requests, 16);
    }
    ifnot (matches.null?()) {
        (matches, users) = remove_matches(matches, users);
    }
    ifnot (users.null?()) {
        users = remove_expired(users, 256);
    }
    return store_data(users, matches, prices, ban_requests, stored_seqno, public_key);
}

;; getters
(cell, cell, cell, cell, int, int) getstorage() method_id {
    ;; dict users, dict matches, dict prices, dict ban_requests, int seqno, int pubkey
    var ds = get_data().begin_parse();
    return (ds~load_dict(),
        ds~load_dict(), 
        ds~load_dict(), 
        ds~load_dict(), 
        ds~load_uint(32), 
        ds.preload_uint(256));
}

(int, int, int, cell) getuser(int wc, int addr) method_id {
    cell users = get_data().begin_parse().preload_dict();
    return get_user(slice_hash(begin_cell().store_uint(4, 3).store_int(wc, 8).store_uint(addr, 256).end_cell().begin_parse()), users);
}

int getprice(int unit_id, int unit_level) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches, cell prices) = (ds~load_dict(), ds~load_dict(), ds.preload_dict());
    return get_price(prices, unit_id, unit_level);
}

(int) getunits(int wc, int addr, int unit_id, int unit_level) method_id {
    (int paid_until, int in_game, int bans_counter, cell units) = getuser(wc, addr);
    return get_unit(units, unit_id, unit_level);
}

(int, int, int, cell, cell, cell,cell) getgame(int idx) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    return get_game(games, idx);
}

int getqueuelen() method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell queue = udict_get_ref(matches, 2, 0);
    var (last_player, idx, f) = udict_get_max_ref(queue, 4);
    if (f) {
        return idx + 1;
    } else {
        return 0;
    }
}

int getplayeridx(int wc, int addr) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    slice owner_address = begin_cell().store_uint(4, 3).store_int(wc, 8).store_uint(addr, 256).end_cell().begin_parse();
    (int paid_until, int game_idx, int bans_counter, cell units) = get_user(slice_hash(owner_address), users);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    int owner_hash = slice_hash(owner_address);
    var idx = 0;
    var f = 0;
    while ( (f == 0) & (idx < 9) ) {
        idx += 1;
        cell player = players.udict_get_ref(8, idx);
        ifnot (player.null?()) {
            int player_hash = player.begin_parse().preload_uint(256);
            if (player_hash == owner_hash) {
                f = 1;
            }
        }            
    }
    if (f) {
        return idx;
    }
    return -1;

}

cell getlocations(int game_idx, int player_idx) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    cell positions = udict_get_ref(current_round, 4, 1);
    return positions.udict_get_ref(8, player_idx);
}

cell getlocalstore(int game_idx) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    return get_store(current_round);
}

tuple getlocallevelstore(int game_idx, int level) method_id {
    cell store = getlocalstore(game_idx);
    if (store.null?()) {
        return nil;
    }
    return get_level_store(store, level);
}

(cell, cell) gettemproundresults(int game_idx) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    return (udict_get_ref(current_round, 4, 3), udict_get_ref(current_round, 4, 4));
}

int getplayerscount(int game_idx) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    return get_players_count(players);
}

int getunitscount(int game_idx, int level) method_id {
    var ds = get_data().begin_parse();
    (cell users, cell matches) = (ds~load_dict(), ds.preload_dict());
    cell games = udict_get_ref(matches, 2, 1);
    var (valid_unitl, should_start_round, timeout, unit_pool_by_level, players, current_round, last_round_results) = get_game(games, game_idx);
    cell units_counter_by_level = udict_get_ref(unit_pool_by_level, 8, 0);
    (slice s_counter, int f) = units_counter_by_level.udict_get?(16, level);
    if (f) {
        return s_counter.preload_uint(16);
    }    
    return 0;
}
;; Global TODO:
;; - add getter for player in round
;; - add getter for results

;; minor TODO:
;; - add method to complain
;; - add method to ban user
